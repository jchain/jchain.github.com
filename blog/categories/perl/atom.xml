<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Perl | A Coding Monkey's Blog]]></title>
  <link href="http://jchain.github.com/blog/categories/perl/atom.xml" rel="self"/>
  <link href="http://jchain.github.com/"/>
  <updated>2013-06-02T00:07:35-05:00</updated>
  <id>http://jchain.github.com/</id>
  <author>
    <name><![CDATA[Zandy]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Fix Neocomplcache to Support Perl Complete]]></title>
    <link href="http://jchain.github.com/blog/2013/06/01/fix-neocomplcache-perlomni/"/>
    <updated>2013-06-01T15:37:24-05:00</updated>
    <id>http://jchain.github.com/blog/2013/06/01/fix-neocomplcache-perlomni</id>
    <content type="html"><![CDATA[<p>I have long been jealous about the great auto-complete feature of Python in Vim. With the wonderful
plugin <a href="https://github.com/Shougo/neocomplcache.vim"><code>neocomplcache</code></a>, once you type <code>.</code> after an object, the memeber methods will pop up.</p>

<p>I want this feature for Perl when I type <code>-&gt;</code>. Actually, until today haven't I realized that
I already own at my finger tip. The answer is <code>neocomplcache</code> and <a href="https://github.com/c9s/perlomni.vim"><code>perlomni</code></a>.</p>

<p>The installation of <code>neocomplcache</code> and <code>perlomni</code> is easy. If you use the settings from the help of
<code>neocomplcache</code>, the key part to triger <code>neocomplcache</code> omni-complete by <code>-&gt;</code> is to change the
setting in <code>.vimrc</code> from</p>

<pre><code>let g:neocomplcache_omni_patterns.perl = '\h\w*-&gt;\h\w*\|\h\w*::'
</code></pre>

<p>to</p>

<pre><code>let g:neocomplcache_omni_patterns.perl = '\h\w*-&gt;\|\h\w*-&gt;\h\w*\|\h\w*::\|\h\w*::\h\w*'
</code></pre>

<p>Make sure <code>omnifunc</code> is <code>PerlComplete</code>.</p>

<p>A little explanation: <code>\h\w*-&gt;</code> will triger the popup window, <code>\h\w*-&gt;\h\w*</code> will complete
as-you-type. The similar situation goes to <code>::</code> operator. But do remember that sometimes <code>::</code> won't
triger neocomplcache if the package is not based on the OO that perlomni supports. In this case,
<code>C-X C-O</code> will always pop up the window.  After this you should see someting like this:</p>

<p><img src="https://dl.dropboxusercontent.com/u/309872/blog/2013-06-01-perlomni-in-vim.png" alt="alt" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introducing Quickcd]]></title>
    <link href="http://jchain.github.com/blog/2013/02/08/intro-quickcd/"/>
    <updated>2013-02-08T14:03:24-06:00</updated>
    <id>http://jchain.github.com/blog/2013/02/08/intro-quickcd</id>
    <content type="html"><![CDATA[<p>I just published the code of <code>quickcd</code> on github. Check it out at <a href="https://github.com/jchain/quickcd">https://github.com/jchain/quickcd</a></p>

<h1>quickcd</h1>

<p>A rewrite of <a href="https://github.com/philc/fuzzycd">fuzzycd</a> in Perl. You only need to type partial directory names to change
directories. It saves you a lot of keystrokes and enhances your productivity, especially when you
navigate in many subdirectories with tricky names.</p>

<p>This script is inspired by <a href="https://github.com/philc/fuzzycd">fuzzycd</a>. Big thanks to the author for sharing his/her great code.
The way of intercepting the system <code>cd</code> is genius. I recommend you to try both scripts and choose
the one you like most.</p>

<h1>Overview</h1>

<p>quickcd enables you to use cd with partial directory names. For example:</p>

<pre><code>$ cd box
  =&gt; Dropbox
$ cd ok
  =&gt; Ebook
</code></pre>

<p>If there is more than one directory containing your cd path, you just need to type one more letter
to take you to the target folder.</p>

<p><code>
~ $ cd D
Make a choice:
[a] Desktop  [b] Documents  [c] Downloads  [d] Dropbox
a
Desktop $
</code></p>

<h1>Why rewrite?</h1>

<p>The differences:</p>

<ol>
<li><p>When your cd path contains capital letter quickcd will match case sensitively. This way can
result in less matches. fuzzycd seems to do case insensitive match all the time.</p></li>
<li><p><strong>quickcd prints out a well-formatted candidates</strong>. It fits the width of the terminal windows and
the columns are aligned neatly. I worked really hard on making this right. fuzzycd candidates
are not always aligned.</p></li>
<li><p>quickcd doesn't support multi-level directory nagivation. Its main focus is current directory.
fuzzycd supports fuzzy jumps to multi-level directory but I rarely use this feature.</p></li>
<li><p>quickcd is written in Perl. Yep, I like Perl! fuzzycd is written in Ruby.</p></li>
</ol>


<h1>Setup</h1>

<p>This following instruction are shamelessly copied from fuzzycd's README.</p>

<p>Modify your ~/.profile (or ~/.bashrc, depending your operating system) and add the following lines.
This assumes you put fuzzycd in the ~/scripts/ directory.</p>

<pre><code>export PATH=~/scripts/fuzzycd/:$PATH
source ~/scripts/fuzzycd/fuzzycd_bash_wrapper.sh
</code></pre>

<p>This will effectively wrap the builtin bash cd command with the fuzzy cd command. Enjoy!</p>

<p><em>Note</em>: If you have any other shell plugins which try to redefine the "cd" function (e.g.
<a href="https://rvm.beginrescueend.com/rvm">rvm</a> does this), make sure that the
<code>source ... fuzzycd_bash_wrapper.sh</code> line comes last in your bash profile. fuzzycd plays nicely with
other bash modification plugins, but it should be loaded last.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Perl one liner: replace text in mulple files]]></title>
    <link href="http://jchain.github.com/blog/2012/11/17/perl-one-liner-replace-text-in-mulple-files/"/>
    <updated>2012-11-17T02:10:00-06:00</updated>
    <id>http://jchain.github.com/blog/2012/11/17/perl-one-liner-replace-text-in-mulple-files</id>
    <content type="html"><![CDATA[<p>Today I got some time to improve my tech blog with <a href="http://octopress.org">Octopress</a>. I found that I couldn't use the
different letter cases as the same category name. Otherwise the category page wouldn't show correct
number of links to the posts under that category. For example, I had to change all <code>git</code> to <code>Git</code> in
the meta info of every posts. Here was what I used to get this job done.</p>

<pre><code>ack "\- git" *.markdown -l | xargs perl -p -i -e 's/- git/- Git/g'
</code></pre>

<p>A little explanation:</p>

<pre><code>-l: ask ack to only show the filename with matched search pattern. You can try first without -l
    option to make sure you find the correct files. And then run with -l option to make the output
    suitable for xargs
-p: read and loop from files instead of STDIN
-i: in-place edit
-e: run the command. Here we do the search and replace operations.
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Perl script: retrieve current weather condition and forecast]]></title>
    <link href="http://jchain.github.com/blog/2012/09/25/perl-script-retrieve-current-weather-condition-and-forecast/"/>
    <updated>2012-09-25T21:33:42-05:00</updated>
    <id>http://jchain.github.com/blog/2012/09/25/perl-script-retrieve-current-weather-condition-and-forecast</id>
    <content type="html"><![CDATA[<p>I'm a little tired of checking out the weather condition via the web browser. In many cases I just
want to see a short report in my terminal. After
readingÂ <a href="http://blogs.perl.org/users/zengargoyle/2012/08/not-to-hot-for-mojo.html">http://blogs.perl.org/users/zengargoyle/2012/08/not-to-hot-for-mojo.html</a>,
which shows how to use Mojolicious to retrieve the current condition and
<a href="http://www.commandlinefu.com/commands/view/4821/get-the-weather-forecast-for-the-next-24-to-48-for-your-location.">http://www.commandlinefu.com/commands/view/4821/get-the-weather-forecast-for-the-next-24-to-48-for-your-location</a>,
which shows how to retried the forecast, I finally wrote something like this</p>

<p>```perl</p>

<h1>!/usr/bin/env perl</h1>

<h1>===============================================================================</h1>

<p>#</p>

<h1>FILE: weather.pl</h1>

<p>#</p>

<h1>USAGE: ./weather.pl</h1>

<p>#</p>

<h1>VERSION: 1.0</h1>

<h1>CREATED: 09/13/2012 10:31:39 PM</h1>

<h1>REVISION: ---</h1>

<h1>===============================================================================</h1>

<p>use strict;
use warnings;
use feature 'say';</p>

<p>use Mojolicious;</p>

<p>my $ua = Mojo::UserAgent->new;
my $dom = $ua->get('http://w1.weather.gov/xml/current_obs/KCID.xml')->res->dom;
my $temp = $dom->find('temperature_string')->[0]->text;
my $weather = $dom->find('weather')->[0]->text;
say "KCID ", $temp, " ", $weather, "\n";</p>

<p>$dom =
$ua->get('http://api.wunderground.com/auto/wui/geo/ForecastXML/index.xml?query=Cedar%20Rapids')->res->dom;</p>

<p>for my $e ($dom->find('simpleforecast forecastday')->each) {
 my $day = $e->date->day->text;
 my $month = substr $e->date->monthname->text, 0, 3;
 my $weekday = substr $e->date->weekday->text, 0, 3;
 my $condition = $e->conditions->text;
 my $high = $e->high->fahrenheit->text;
 my $low = $e->low->fahrenheit->text;</p>

<p>printf "%s %s %s, Low: %d, High: %d, %s\n", $weekday, $month, $day, $low, $high, $condition;
}
```</p>

<p>This is how it runs from the terminal:</p>

<p>```bash
[zandyware@zandyware] bin $ ./weather.pl
KCID 63.0 F (17.2 C) Fair</p>

<p>Tue Sep 25, Low: 46, High: 81, Clear
Wed Sep 26, Low: 39, High: 70, Clear
Thu Sep 27, Low: 45, High: 70, Clear
Fri Sep 28, Low: 46, High: 70, Partly Cloudy
Sat Sep 29, Low: 45, High: 72, Clear
Sun Sep 30, Low: 41, High: 73, Clear
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Use Perl like sed]]></title>
    <link href="http://jchain.github.com/blog/2012/09/14/use-perl-like-sed/"/>
    <updated>2012-09-14T11:29:58-05:00</updated>
    <id>http://jchain.github.com/blog/2012/09/14/use-perl-like-sed</id>
    <content type="html"><![CDATA[<p>Recently I wanted to use Perl and Bash to deal with a large number of files. I ended up needing
in-line string substitution to create new shell commands. I vaguely had an idea that I should use
'sed' to do the text transform but by any chance I would like to use Perl. I rarely use Perl as
one-liner. It turned out that this is the correct way to do so</p>

<pre><code>find . -name "*.java" -print | perl -ne 's/java/java.old/g &amp;&amp; print'
</code></pre>
]]></content>
  </entry>
  
</feed>
